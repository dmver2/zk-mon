package ru.vtb.afsc.pe.nio;

import org.apache.commons.lang3.tuple.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import ru.vtb.afsc.pe.nio.AsyncSocketClient.AttachmentNio2;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class AsyncClient {
    private static final Logger LOG = LoggerFactory.getLogger(AsyncClient.class);

    public static void main(final String[] args) throws Exception {
        final List<Pair<AsyncSocketClient, String>> clients = Stream.of(args)
                .map(arg ->
                        {
                            final String[] lexemes = arg.split(":");
                            final String host = lexemes[0];
                            final int port = Integer.parseInt(lexemes[1]);
                            try {
                                return Pair.of(new AsyncSocketClient(host, port).start(null),
                                        String.format("GET /commands/mntr HTTP/1.1%n"
                                                + "User-Agent: curl/7.29.0%n"
                                                + "Host: %s:%d%n"
                                                + "Connection: Keep-Alive%n"
                                                + "Accept: */*%n%n", host, port)
                                );
                            } catch (final IOException e) {
                                throw new Error(String.format("NON-TRAPPABLE ERROR (%s:%d)", host,
                                        port), e);
                            }
                        }
                ).collect(Collectors.toList());
        final BufferedReader br = new BufferedReader(new InputStreamReader(System.in,
                StandardCharsets.UTF_8));

        LOG.debug("Message to server:");
        for (String line; null != (line = br.readLine()); ) {
            switch (line) {
            case "c":
                clients.stream().filter(pair -> pair.getLeft().getChannel().isOpen())
                        .peek(pair -> LOG.info("disconnecting {}...",
                                pair.getLeft().getHostAddress()))
                        .map(Pair::getLeft).forEach(AsyncSocketClient::stop);
                break;
            case "o":
                clients.stream().filter(pair -> !pair.getLeft().getChannel().isOpen())
                        .peek(pair -> LOG.info("connecting {}...",
                                pair.getLeft().getHostAddress()))
                        .map(Pair::getLeft)
                        .filter(Objects::nonNull)
                        .forEach(asyncSocketClient -> {
                            try {
                                asyncSocketClient.start(null);
                            } catch (final IOException e) {
                                throw new Error("NON-TRAPPABLE ERROR", e);
                            }
                        });
                break;

            case "q":
                break;

            default:
                clients.stream().filter(pair -> pair.getLeft().getChannel().isOpen())
                        .forEach(pair -> pair.getLeft().sendMessage(pair.getRight().getBytes(
                                StandardCharsets.ISO_8859_1)));
                LOG.debug("Message to server sent:");
                @SuppressWarnings("unchecked") final CompletableFuture<AttachmentNio2>[] crop =
                        clients.stream().filter(pair -> pair.getLeft().getChannel().isOpen())
                                .map(pair -> pair.getLeft().getReadComplete()
                                ).toArray(CompletableFuture[]::new);

                try {
                    CompletableFuture.allOf(crop).thenAccept(future -> {
                        LOG.info("/ALL PENDING READ ASSUMED COMPLETED/");
                        Stream.of(crop).forEach(cf -> {
                            final AttachmentNio2 result = cf.getNow(null);
                            LOG.info("{}", result);
                        });
                    }).get(1, TimeUnit.SECONDS);
                } catch (final InterruptedException | ExecutionException | TimeoutException e) {
                    LOG.error("ERROR GETTING ALL FUTURES", e);
                }
            } //switch
            if ("q".equals(line)) {
                break;
            }
        }
    }
}
package ru.vtb.afsc.pe.nio;

import org.apache.commons.lang3.tuple.Pair;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.URI;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;


public class Nio1Test {

    private static final Logger LOG = LoggerFactory.getLogger(Nio1Test.class);

    private static String doRepair(final String textHeaderValue) {
        final String correctHeaderValue = new String(
                textHeaderValue.getBytes(StandardCharsets.ISO_8859_1),
                StandardCharsets.UTF_8);
        LOG.debug("Repaired: %s -> %s\n", textHeaderValue, correctHeaderValue);
        return correctHeaderValue;
    }

    @Test
    void charsetTest() throws Exception {
        final URI uri = Nio1Test.class.getResource("/__files/json/nio/utf-8-response.txt").toURI();
        final ByteBuffer rawBuff = ByteBuffer.wrap(Files.readAllBytes(Paths.get(uri)));
        final String mbStr = StandardCharsets.ISO_8859_1.decode(rawBuff).toString();
        rawBuff.rewind(); // flip is excessive
        final String utfStr = StandardCharsets.UTF_8.decode(rawBuff).toString();
        Assertions.assertEquals(mbStr.length(), rawBuff.limit());

        doEncodingFixTest(mbStr, utfStr, "Russian-Header:");
        doEncodingFixTest(mbStr, utfStr, "\"russian_value\" : ");
    }

    private void doEncodingFixTest(final String mbStr, final String utfStr, final String token) {
        final Pair<String, Integer> invalidHeaderValue = getSubstringByToken(mbStr, token);
        final String repaired = doRepair(invalidHeaderValue.getLeft());

        Assertions.assertTrue(utfStr.contains(repaired));
        final Pair<String, Integer> originalStr = getSubstringByToken(utfStr, token);
        Assertions.assertEquals(originalStr.getLeft(), repaired);
        Assertions.assertTrue(originalStr.getRight() <= invalidHeaderValue.getRight());
    }

    private Pair<String, Integer> getSubstringByToken(final String mbStr, final String token) {
        final int startPos;
        startPos = mbStr.indexOf(token) + token.length();
        return Pair.of(mbStr.substring(startPos, mbStr.indexOf("\n", startPos)), startPos);
    }

}

package ru.vtb.afsc.pe.nio;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.net.StandardSocketOptions;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.nio.charset.StandardCharsets;

public class NonBlockingIOClient {
    private static final Logger LOG = LoggerFactory.getLogger(NonBlockingIOClient.class);
    private final String hostName = "localhost";
    private final Object lock = new Object();
    private final int port = 8081;

    public static void main(final String[] args) {
        final NonBlockingIOClient client = new NonBlockingIOClient();
        try {
            client.getResponseFromServer("GET /commands/mntr HTTP/1.1%n"
                    + "User-Agent: curl/7.29.0%n"
                    + "Host: localhost:8081%n"
                    + "Connection: Keep-Alive%n"
                    + "Accept: */*%n%n");
        } catch (final InterruptedException e) {
            LOG.error("FATAL ERROR", e);
        }
    }

    //main client method
    public void getResponseFromServer(final String request) throws InterruptedException {
        try {
            //non blocking client socket
            final SocketChannel sc = SocketChannel.open();
            sc.configureBlocking(false);
            sc.setOption(StandardSocketOptions.SO_KEEPALIVE, true);

            final InetSocketAddress addr = new InetSocketAddress(hostName, port);

            sc.connect(addr);

            final ByteBuffer bb = ByteBuffer.allocate(256);
            bb.clear();
            bb.put(request.getBytes(StandardCharsets.UTF_8));
            bb.flip();

            //process response
            final Selector selector = Selector.open();
            final Att att = new Att(bb, addr, new StringBuilder(0x200));
            final SelectionKey sk = sc.register(selector,
                    SelectionKey.OP_READ | SelectionKey.OP_CONNECT | SelectionKey.OP_WRITE,
                    att);
            LOG.debug("ATTACHED: {}", sk);
            Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                LOG.info("SHUTDOWN CAUGHT");
                sk.cancel();
                LOG.info("CANCELLED");
            }));

            while (true) {
                if (selector.select() > 0) {
                    if (processServerResponse(selector)) {
                        LOG.debug("Received : {}", att.sb.length());
                        LOG.trace("{}", att.sb);
                        att.sb.delete(0, att.sb.length());
                        //break;
                        synchronized (lock) {
                            lock.wait(1000);
                        }
                        bb.clear();
                        bb.put(request.getBytes(StandardCharsets.UTF_8));
                        bb.flip();
                        writeBytes(sk);
                    }
                }
            }
        } catch (final IOException e) {
            LOG.error("", e);
        }
    }

    public boolean processServerResponse(final Selector s) {
        for (final SelectionKey sk : s.selectedKeys()) {
            s.selectedKeys().remove(sk);
            final SocketChannel sc = (SocketChannel) sk.channel();
            try {
                if (!sk.isValid()) {
                    continue;
                }

                LOG.trace("0x{} 0x{}", Integer.toHexString(sk.interestOps()),
                        Integer.toHexString(sk.readyOps()));

                if (sk.isConnectable()) {
                    try {
                        sc.finishConnect();
                        writeBytes(sk);
                    } catch (final IOException iox) {
                        LOG.error("CONNECT FAIL", iox);
                        sk.cancel();
                        sc.close();
                        return true;
                    }
/*
//TODO: when to write?
                } else if (sk.isWritable()) {
                    if(requestLength <= (written = sc.write(bb))) {
                        // continue writing
                        sc.write(bb);
                    }
*/
                } else {
                    if (sk.isReadable()) {
                        if (readBytes(sk)) {
                            return true;
                        }
                    }
                }

            } catch (final Exception e) {
                LOG.error("GENERAL PROTECTION FAULT", e);
                return true;
            }
        }
        return false;
    }

    private boolean readBytes(final SelectionKey sk) throws IOException {
        final Att attachment = (Att) sk.attachment();
        final SocketChannel sc = (SocketChannel) sk.channel();
        final ByteBuffer bb = attachment.buffer;
        bb.clear();
        final int read = sc.read(bb);
        bb.flip();
        final String chunk =
                StandardCharsets.ISO_8859_1.decode(bb).toString();
        LOG.trace("response chunk: " + chunk);
        attachment.sb.append(chunk);
        // no more data
        //            sk.cancel();
        return -1 == read || chunk.endsWith("}");
    }

    private void writeBytes(final SelectionKey sk) throws IOException {
        final Att attachment = (Att) sk.attachment();
        final SocketChannel sc = (SocketChannel) sk.channel();
        final ByteBuffer bb = attachment.buffer;
        final int written = sc.write(bb);
        LOG.debug("WRITTEN {} bytes ({})", written, written == bb.limit()
                                                    ? "ALL"
                                                    : String.format("less than %d", bb.limit()));
        if (written >= bb.limit()) {
            readBytes(sk);
        }
    }

    private static final class Att {
        final SocketAddress address;
        final ByteBuffer buffer;
        final StringBuilder sb;

        private Att(final ByteBuffer buffer, final SocketAddress address,
                    final StringBuilder stringBuilder) {
            this.buffer = buffer;
            this.address = address;
            sb = stringBuilder;
        }
    }
}